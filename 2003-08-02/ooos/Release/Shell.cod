; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	Shell.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_15NAHPJHLP@?$AA?$DO?$AA?5?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@GKFKAGNK@?$AAs?$AAn?$AAa?$AAk?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1DE@JPDJLOBC@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAn?$AAa?$AAk?$AAe?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@GFEGCGOG@?$AAD?$AAo?$AAn?$AAe?$AA?6?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcmp@@YAHPA_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Shell@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessEntry@Shell@@UAEXPAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Shell@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?strcmp@@YAHPA_W0@Z				; strcmp
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\shell.cpp
;	COMDAT ?strcmp@@YAHPA_W0@Z
_TEXT	SEGMENT
_L$ = 8
_R$ = 12
?strcmp@@YAHPA_W0@Z PROC NEAR				; strcmp, COMDAT

; 9    : {

  00000	53		 push	 ebx

; 10   : 	int i;
; 11   : 	for (i = 0; L[i] != NULL && R[i] != NULL; ++i)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _L$[esp]
  00005	55		 push	 ebp
  00006	8b 6c 24 10	 mov	 ebp, DWORD PTR _R$[esp+4]
  0000a	56		 push	 esi
  0000b	33 f6		 xor	 esi, esi
  0000d	66 39 33	 cmp	 WORD PTR [ebx], si
  00010	57		 push	 edi
  00011	74 2a		 je	 SHORT $L582
  00013	8b fd		 mov	 edi, ebp
  00015	8b c3		 mov	 eax, ebx
  00017	2b fb		 sub	 edi, ebx

; 19   : 		return 0;
; 20   : 	return 1;
; 21   : }

  00019	8d a4 24 00 00
	00 00		 npad	 7

; 10   : 	int i;
; 11   : 	for (i = 0; L[i] != NULL && R[i] != NULL; ++i)

$L652:
  00020	66 8b 0c 07	 mov	 cx, WORD PTR [edi+eax]
  00024	66 85 c9	 test	 cx, cx
  00027	74 14		 je	 SHORT $L582

; 12   : 	{
; 13   : 		if (L[i] > R[i])

  00029	66 8b 10	 mov	 dx, WORD PTR [eax]
  0002c	66 3b d1	 cmp	 dx, cx
  0002f	77 21		 ja	 SHORT $L649

; 15   : 		if (L[i] < R[i])

  00031	72 29		 jb	 SHORT $L650
  00033	83 c0 02	 add	 eax, 2
  00036	46		 inc	 esi
  00037	66 83 38 00	 cmp	 WORD PTR [eax], 0
  0003b	75 e3		 jne	 SHORT $L652
$L582:

; 17   : 	}
; 18   : 	if (L[i] == R[i])

  0003d	66 8b 04 73	 mov	 ax, WORD PTR [ebx+esi*2]
  00041	33 c9		 xor	 ecx, ecx
  00043	66 3b 44 75 00	 cmp	 ax, WORD PTR [ebp+esi*2]
  00048	5f		 pop	 edi
  00049	0f 95 c1	 setne	 cl
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	5b		 pop	 ebx
  0004f	8b c1		 mov	 eax, ecx

; 19   : 		return 0;
; 20   : 	return 1;
; 21   : }

  00051	c3		 ret	 0
$L649:
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5d		 pop	 ebp

; 14   : 			return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	5b		 pop	 ebx

; 19   : 		return 0;
; 20   : 	return 1;
; 21   : }

  0005b	c3		 ret	 0
$L650:
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp

; 16   : 			return -1;

  0005f	83 c8 ff	 or	 eax, -1
  00062	5b		 pop	 ebx

; 19   : 		return 0;
; 20   : 	return 1;
; 21   : }

  00063	c3		 ret	 0
?strcmp@@YAHPA_W0@Z ENDP				; strcmp
_TEXT	ENDS
PUBLIC	??1Shell@@QAE@XZ				; Shell::~Shell
PUBLIC	?ProcessEntry@Shell@@UAEXPAPAX@Z		; Shell::ProcessEntry
PUBLIC	??_7Shell@@6B@					; Shell::`vftable'
EXTRN	??1Process@@QAE@XZ:NEAR				; Process::~Process
;	COMDAT ??_7Shell@@6B@
CONST	SEGMENT
??_7Shell@@6B@ DD FLAT:?ProcessEntry@Shell@@UAEXPAPAX@Z	; Shell::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1Shell@@QAE@XZ
_TEXT	SEGMENT
??1Shell@@QAE@XZ PROC NEAR				; Shell::~Shell, COMDAT
; _this$ = ecx

; 24   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7Shell@@6B@

; 25   : }

  00006	e9 00 00 00 00	 jmp	 ??1Process@@QAE@XZ	; Process::~Process
??1Shell@@QAE@XZ ENDP					; Shell::~Shell
_TEXT	ENDS
PUBLIC	??_C@_15NAHPJHLP@?$AA?$DO?$AA?5?$AA?$AA@	; `string'
PUBLIC	??_C@_1M@GKFKAGNK@?$AAs?$AAn?$AAa?$AAk?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@JPDJLOBC@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAn?$AAa?$AAk?$AAe?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe@ ; `string'
PUBLIC	??_C@_1M@GFEGCGOG@?$AAD?$AAo?$AAn?$AAe?$AA?6?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	?CreateProcess@@YAHPAVProcess@@@Z:NEAR		; CreateProcess
EXTRN	?GetKey@KeyboardDriver@@SA_WXZ:NEAR		; KeyboardDriver::GetKey
EXTRN	?WriteString@VideoDriver@@QAEXPA_W@Z:NEAR	; VideoDriver::WriteString
EXTRN	?pDisp@@3PAVVideoDriver@@A:DWORD		; pDisp
EXTRN	??0Snake@@QAE@PAX0@Z:NEAR			; Snake::Snake
;	COMDAT ??_C@_15NAHPJHLP@?$AA?$DO?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_15NAHPJHLP@?$AA?$DO?$AA?5?$AA?$AA@ DB '>', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GKFKAGNK@?$AAs?$AAn?$AAa?$AAk?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GKFKAGNK@?$AAs?$AAn?$AAa?$AAk?$AAe?$AA?$AA@ DB 's', 00H, 'n', 00H
	DB	'a', 00H, 'k', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@JPDJLOBC@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAn?$AAa?$AAk?$AAe?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe@
CONST	SEGMENT
??_C@_1DE@JPDJLOBC@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAn?$AAa?$AAk?$AAe?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe@ DB 'C'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'k', 00H, 'e'
	DB	00H, ' ', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, '.', 00H, '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@GFEGCGOG@?$AAD?$AAo?$AAn?$AAe?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1M@GFEGCGOG@?$AAD?$AAo?$AAn?$AAe?$AA?6?$AA?$AA@ DB 'D', 00H, 'o', 00H
	DB	'n', 00H, 'e', 00H, 0aH, 00H, 00H, 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?ProcessEntry@Shell@@UAEXPAPAX@Z
_TEXT	SEGMENT
_TempChr$ = -12
_BuffSize$ = -8
tv201 = -4
_args$ = 8
?ProcessEntry@Shell@@UAEXPAPAX@Z PROC NEAR		; Shell::ProcessEntry, COMDAT
; _this$ = ecx

; 29   : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 30   : 	wchar_t TempChr[2];
; 31   : 	TempChr[1] = 0;

  00007	33 ff		 xor	 edi, edi

; 32   : 	wchar_t *Buffer;
; 33   : 	int BuffSize = 16;

  00009	bd 10 00 00 00	 mov	 ebp, 16			; 00000010H

; 34   : 	int BuffCount = 0;
; 35   : 	Buffer = new wchar_t[BuffSize];

  0000e	6a 20		 push	 32			; 00000020H
  00010	66 89 7c 24 16	 mov	 WORD PTR _TempChr$[esp+34], di
  00015	89 6c 24 18	 mov	 DWORD PTR _BuffSize$[esp+32], ebp
  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	8b d8		 mov	 ebx, eax
  00020	83 c4 04	 add	 esp, 4

; 36   : 	*Buffer = '\0';

  00023	66 89 3b	 mov	 WORD PTR [ebx], di
$L670:

; 37   : 	int Temp;
; 38   : 
; 39   : 	pDisp->WriteString(L"> ");

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDisp@@3PAVVideoDriver@@A ; pDisp
  0002c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_15NAHPJHLP@?$AA?$DO?$AA?5?$AA?$AA@
  00031	e8 00 00 00 00	 call	 ?WriteString@VideoDriver@@QAEXPA_W@Z ; VideoDriver::WriteString
$L603:

; 40   : 
; 41   : 	while(1)
; 42   : 	{
; 43   : 		bool full = false;
; 44   : 		//printf("S");
; 45   : 		//i_VideoDriver.WriteHexByte(KeyboardDriver::KeysBuffered());
; 46   : 		//i_VideoDriver.WriteString(L" ");
; 47   : 		TempChr[0] = KeyboardDriver::GetKey();

  00036	e8 00 00 00 00	 call	 ?GetKey@KeyboardDriver@@SA_WXZ ; KeyboardDriver::GetKey

; 48   : 		if (TempChr[0] != NULL)

  0003b	66 85 c0	 test	 ax, ax
  0003e	66 89 44 24 10	 mov	 WORD PTR _TempChr$[esp+28], ax
  00043	74 f1		 je	 SHORT $L603

; 49   : 		{
; 50   : 			if (TempChr[0] != '\n')

  00045	66 3d 0a 00	 cmp	 ax, 10			; 0000000aH
  00049	0f 84 7d 00 00
	00		 je	 $L607

; 51   : 			{
; 52   : 				if (BuffCount < BuffSize -1)

  0004f	8d 4d ff	 lea	 ecx, DWORD PTR [ebp-1]
  00052	3b f9		 cmp	 edi, ecx
  00054	7d 10		 jge	 SHORT $L608

; 53   : 				{
; 54   : 					Buffer[BuffCount] = TempChr[0];

  00056	66 89 04 7b	 mov	 WORD PTR [ebx+edi*2], ax

; 55   : 					BuffCount++;

  0005a	47		 inc	 edi

; 56   : 					Buffer[BuffCount] = '\0';

  0005b	66 c7 04 7b 00
	00		 mov	 WORD PTR [ebx+edi*2], 0

; 57   : 				}
; 58   : 				else

  00061	e9 cc 00 00 00	 jmp	 $L668
$L608:

; 59   : 				{
; 60   : 					wchar_t* TempBuffer;
; 61   : 					TempBuffer = new wchar_t[BuffSize *2];

  00066	8d 14 ad 00 00
	00 00		 lea	 edx, DWORD PTR [ebp*4]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00073	8b f0		 mov	 esi, eax
  00075	83 c4 04	 add	 esp, 4

; 62   : 					if (TempBuffer != NULL)

  00078	85 f6		 test	 esi, esi
  0007a	74 ba		 je	 SHORT $L603

; 63   : 					{
; 64   : 						for (int i = 0; i < BuffCount + 1; ++i)

  0007c	8d 6f 01	 lea	 ebp, DWORD PTR [edi+1]
  0007f	85 ed		 test	 ebp, ebp
  00081	89 6c 24 18	 mov	 DWORD PTR tv201[esp+28], ebp
  00085	7e 1a		 jle	 SHORT $L617
  00087	8b cb		 mov	 ecx, ebx
  00089	2b ce		 sub	 ecx, esi
  0008b	8b d5		 mov	 edx, ebp

; 131  : }

  0008d	8d 49 00	 npad	 3

; 63   : 					{
; 64   : 						for (int i = 0; i < BuffCount + 1; ++i)

$L615:

; 65   : 						{
; 66   : 							TempBuffer[i] = Buffer[i];

  00090	66 8b 2c 01	 mov	 bp, WORD PTR [ecx+eax]
  00094	66 89 28	 mov	 WORD PTR [eax], bp
  00097	83 c0 02	 add	 eax, 2
  0009a	4a		 dec	 edx
  0009b	75 f3		 jne	 SHORT $L615

; 63   : 					{
; 64   : 						for (int i = 0; i < BuffCount + 1; ++i)

  0009d	8b 6c 24 18	 mov	 ebp, DWORD PTR tv201[esp+28]
$L617:

; 67   : 						}
; 68   : 						delete[] Buffer;

  000a1	53		 push	 ebx
  000a2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 69   : 						Buffer = TempBuffer;
; 70   : 						BuffSize = 2*BuffSize;
; 71   : 						Buffer[BuffCount] = TempChr[0];

  000a7	66 8b 54 24 14	 mov	 dx, WORD PTR _TempChr$[esp+32]
  000ac	8b 44 24 18	 mov	 eax, DWORD PTR _BuffSize$[esp+32]
  000b0	66 89 14 7e	 mov	 WORD PTR [esi+edi*2], dx
  000b4	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]

; 72   : 						BuffCount++;

  000b7	8b fd		 mov	 edi, ebp
  000b9	83 c4 04	 add	 esp, 4
  000bc	8b de		 mov	 ebx, esi
  000be	89 4c 24 14	 mov	 DWORD PTR _BuffSize$[esp+28], ecx

; 73   : 						Buffer[BuffCount] = '\0';

  000c2	66 c7 04 7e 00
	00		 mov	 WORD PTR [esi+edi*2], 0

; 74   : 					}
; 75   : 					else

  000c8	8b e9		 mov	 ebp, ecx
  000ca	eb 66		 jmp	 SHORT $L668
$L607:

; 76   : 					{
; 77   : 						full = true;
; 78   : 					}
; 79   : 				}
; 80   : 			}
; 81   : 			else
; 82   : 			{
; 83   : 				// got command,s ee if we can process it
; 84   : 				if (strcmp(Buffer,L"snake") == 0)

  000cc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@GKFKAGNK@?$AAs?$AAn?$AAa?$AAk?$AAe?$AA?$AA@
  000d1	53		 push	 ebx
  000d2	e8 00 00 00 00	 call	 ?strcmp@@YAHPA_W0@Z	; strcmp
  000d7	83 c4 08	 add	 esp, 8
  000da	85 c0		 test	 eax, eax
  000dc	75 4f		 jne	 SHORT $L621

; 85   : 				{
; 86   : 					// Launchign Snake
; 87   : 					pDisp->WriteString(L"Creating Snake Process...");

  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDisp@@3PAVVideoDriver@@A ; pDisp
  000e4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1DE@JPDJLOBC@?$AAC?$AAr?$AAe?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAn?$AAa?$AAk?$AAe?$AA?5?$AAP?$AAr?$AAo?$AAc?$AAe@
  000e9	e8 00 00 00 00	 call	 ?WriteString@VideoDriver@@QAEXPA_W@Z ; VideoDriver::WriteString

; 88   : 					Process * SnakeProcess = new Snake(reinterpret_cast<void *> (0xA13000), reinterpret_cast<void *> (0xA14000));

  000ee	68 80 04 00 00	 push	 1152			; 00000480H
  000f3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000f8	83 c4 04	 add	 esp, 4
  000fb	85 c0		 test	 eax, eax
  000fd	74 13		 je	 SHORT $L663
  000ff	68 00 40 a1 00	 push	 10567680		; 00a14000H
  00104	68 00 30 a1 00	 push	 10563584		; 00a13000H
  00109	8b c8		 mov	 ecx, eax
  0010b	e8 00 00 00 00	 call	 ??0Snake@@QAE@PAX0@Z	; Snake::Snake
  00110	eb 02		 jmp	 SHORT $L664
$L663:
  00112	33 c0		 xor	 eax, eax
$L664:

; 89   : 					CreateProcess(SnakeProcess);

  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?CreateProcess@@YAHPAVProcess@@@Z ; CreateProcess

; 90   : 					pDisp->WriteString(L"Done\n");

  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDisp@@3PAVVideoDriver@@A ; pDisp
  00120	83 c4 04	 add	 esp, 4
  00123	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@GFEGCGOG@?$AAD?$AAo?$AAn?$AAe?$AA?6?$AA?$AA@
  00128	e8 00 00 00 00	 call	 ?WriteString@VideoDriver@@QAEXPA_W@Z ; VideoDriver::WriteString
$L621:

; 91   : 				}
; 92   : 
; 93   : 
; 94   : 				// Now clear buffer ready for enxt command
; 95   : 				full = false;
; 96   : 				BuffCount = 0;

  0012d	33 ff		 xor	 edi, edi

; 97   : 				Buffer[0] = '\0';

  0012f	66 89 3b	 mov	 WORD PTR [ebx], di
$L668:

; 98   : 			}
; 99   : 
; 100  : 			if (full == false)
; 101  : 			{
; 102  : 				pDisp->WriteString(TempChr);

  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDisp@@3PAVVideoDriver@@A ; pDisp
  00138	8d 44 24 10	 lea	 eax, DWORD PTR _TempChr$[esp+28]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 ?WriteString@VideoDriver@@QAEXPA_W@Z ; VideoDriver::WriteString

; 103  : 				if (TempChr[0] == '\n')

  00142	66 83 7c 24 10
	0a		 cmp	 WORD PTR _TempChr$[esp+28], 10 ; 0000000aH
  00148	0f 85 e8 fe ff
	ff		 jne	 $L603

; 104  : 				{
; 105  : 					pDisp->WriteString(L"> ");
; 106  : 				}
; 107  : 			}
; 108  : 		}
; 109  :         //i_VideoDriver.WriteString(L" ");
; 110  : 		//i_VideoDriver.WriteHexByte(TempChar[0]);
; 111  :         //i_VideoDriver.WriteString(L"\n");
; 112  : 
; 113  : 		/*BYTE Return, Command;
; 114  : 
; 115  : 		Command = 0x0A;
; 116  : 		__asm
; 117  : 		{
; 118  : 			MOV al, Command
; 119  : 			OUT IO_PIC1, al
; 120  : 			IN al, IO_PIC1
; 121  : 			MOV Return, al
; 122  : 		}
; 123  : 		i_VideoDriver.WriteHexByte(Return);*/
; 124  : 		//i_VideoDriver.WriteString("\n");
; 125  : 		//Temp = KeyboardDriver::KeysBuffered();
; 126  : 		//while (KeyboardDriver::KeysBuffered() == Temp);
; 127  : 
; 128  : 
; 129  : 
; 130  : 	}

  0014e	e9 d3 fe ff ff	 jmp	 $L670
?ProcessEntry@Shell@@UAEXPAPAX@Z ENDP			; Shell::ProcessEntry
_TEXT	ENDS
END
