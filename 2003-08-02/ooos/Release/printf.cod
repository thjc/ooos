; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	printf.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OutChar@@YAXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?printf@@YAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?OutChar@@YAXD@Z				; OutChar
EXTRN	?WriteString@VideoDriver@@QAEXPA_W@Z:NEAR	; VideoDriver::WriteString
EXTRN	?pDisp@@3PAVVideoDriver@@A:DWORD		; pDisp
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\printf.cpp
;	COMDAT ?OutChar@@YAXD@Z
_TEXT	SEGMENT
_w_v$ = 8
_v$ = 8
?OutChar@@YAXD@Z PROC NEAR				; OutChar, COMDAT

; 8    : 	wchar_t w_v[2];
; 9    : 	w_v[0] = v;

  00000	66 0f b6 44 24
	04		 movzx	 ax, BYTE PTR _v$[esp-4]

; 10   : 	w_v[1] = 0;
; 11   : 	pDisp->WriteString(w_v);

  00006	8d 4c 24 04	 lea	 ecx, DWORD PTR _w_v$[esp-4]
  0000a	51		 push	 ecx
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pDisp@@3PAVVideoDriver@@A ; pDisp
  00011	66 89 44 24 08	 mov	 WORD PTR _w_v$[esp], ax
  00016	66 c7 44 24 0a
	00 00		 mov	 WORD PTR _w_v$[esp+2], 0
  0001d	e8 00 00 00 00	 call	 ?WriteString@VideoDriver@@QAEXPA_W@Z ; VideoDriver::WriteString

; 12   : }

  00022	c3		 ret	 0
?OutChar@@YAXD@Z ENDP					; OutChar
_TEXT	ENDS
PUBLIC	?printf@@YAXPBDZZ				; printf
; Function compile flags: /Ogty
;	COMDAT ?printf@@YAXPBDZZ
_TEXT	SEGMENT
tv264 = -4
_arg$ = 8
?printf@@YAXPBDZZ PROC NEAR				; printf, COMDAT

; 23   : void printf(const char *arg, ...) {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 24   : 	int cnt=0;
; 25   : 
; 26   : 	unsigned int coffset=(((unsigned int)&arg)+0x00000004);	//address of first argument
; 27   : 
; 28   : 	if(arg[cnt]==0) {

  00003	8b 6c 24 10	 mov	 ebp, DWORD PTR _arg$[esp+8]
  00007	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  0000b	8d 5c 24 14	 lea	 ebx, DWORD PTR _arg$[esp+12]
  0000f	74 69		 je	 SHORT $L515
  00011	56		 push	 esi
  00012	57		 push	 edi

; 29   : 		return /*-1*/;
; 30   : 	}
; 31   : 
; 32   : 	while(arg[cnt]!=0) {

  00013	8d 7d 01	 lea	 edi, DWORD PTR [ebp+1]
$L514:

; 33   : 		if(arg[cnt+1]!=0) {

  00016	8a 07		 mov	 al, BYTE PTR [edi]
  00018	84 c0		 test	 al, al
  0001a	0f 84 a4 00 00
	00		 je	 $L516

; 34   : 			if(arg[cnt]=='%'&&arg[cnt+1]=='d') {

  00020	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
  00023	80 f9 25	 cmp	 cl, 37			; 00000025H
  00026	0f 85 9d 00 00
	00		 jne	 $L532
  0002c	3c 64		 cmp	 al, 100			; 00000064H
  0002e	75 4e		 jne	 SHORT $L517

; 35   : 				int val=(int)(*(int *)coffset);

  00030	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 36   : 				cnt+=2;

  00032	83 c7 02	 add	 edi, 2
  00035	83 c5 02	 add	 ebp, 2
  00038	89 7c 24 10	 mov	 DWORD PTR tv264[esp+20], edi

; 37   : 				coffset+=0x00000004;

  0003c	83 c3 04	 add	 ebx, 4

; 38   : 
; 39   : 				unsigned int foo=1000000000;

  0003f	be 00 ca 9a 3b	 mov	 esi, 1000000000		; 3b9aca00H
$L522:

; 40   : 				do {
; 41   : 					OutChar('0'+val/foo);

  00044	8b c1		 mov	 eax, ecx
  00046	33 d2		 xor	 edx, edx
  00048	f7 f6		 div	 esi
  0004a	04 30		 add	 al, 48			; 00000030H
  0004c	8b fa		 mov	 edi, edx
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?OutChar@@YAXD@Z	; OutChar
  00054	83 c4 04	 add	 esp, 4

; 42   : 					val=val%foo;
; 43   : 					if(foo==1)

  00057	83 fe 01	 cmp	 esi, 1
  0005a	8b cf		 mov	 ecx, edi
  0005c	74 10		 je	 SHORT $L561

; 44   : 						foo=0;
; 45   : 					else 
; 46   : 						foo/=10;

  0005e	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00063	f7 e6		 mul	 esi
  00065	c1 ea 03	 shr	 edx, 3
  00068	8b f2		 mov	 esi, edx

; 47   : 				} while (foo!=0);

  0006a	85 f6		 test	 esi, esi
  0006c	75 d6		 jne	 SHORT $L522
$L561:

; 72   : 			cnt++;

  0006e	8b 7c 24 10	 mov	 edi, DWORD PTR tv264[esp+20]
$L540:

; 29   : 		return /*-1*/;
; 30   : 	}
; 31   : 
; 32   : 	while(arg[cnt]!=0) {

  00072	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  00076	75 9e		 jne	 SHORT $L514
  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
$L515:
  0007a	5d		 pop	 ebp
  0007b	5b		 pop	 ebx

; 73   : 		}
; 74   : 	}
; 75   : 
; 76   : }

  0007c	59		 pop	 ecx
  0007d	c3		 ret	 0
$L517:

; 48   : 
; 49   : 
; 50   : 			}
; 51   : 			else if (arg[cnt]=='%'&&arg[cnt+1]=='c') {

  0007e	3c 63		 cmp	 al, 99			; 00000063H
  00080	75 18		 jne	 SHORT $L528

; 52   : 				OutChar((char)(*(char *)coffset));

  00082	33 c0		 xor	 eax, eax
  00084	8a 03		 mov	 al, BYTE PTR [ebx]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ?OutChar@@YAXD@Z	; OutChar
  0008c	83 c4 04	 add	 esp, 4

; 53   : 				coffset+=0x00000004;

  0008f	83 c3 04	 add	 ebx, 4

; 54   : 				cnt+=2;

  00092	83 c7 02	 add	 edi, 2
  00095	83 c5 02	 add	 ebp, 2

; 55   : 			}
; 56   : 			else if (arg[cnt]=='%'&&arg[cnt+1]=='s') {

  00098	eb d8		 jmp	 SHORT $L540
$L528:
  0009a	3c 73		 cmp	 al, 115			; 00000073H
  0009c	75 2b		 jne	 SHORT $L532

; 57   : 				char *str=(char *)*(int *)coffset;

  0009e	8b 33		 mov	 esi, DWORD PTR [ebx]

; 58   : 				while ((*str)!=0) {
; 59   : 					OutChar(*str);

  000a0	33 c0		 xor	 eax, eax
  000a2	8a 06		 mov	 al, BYTE PTR [esi]
  000a4	84 c0		 test	 al, al
  000a6	74 11		 je	 SHORT $L538
$L537:
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?OutChar@@YAXD@Z	; OutChar
  000ae	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  000b1	83 c4 04	 add	 esp, 4

; 60   : 					str++;

  000b4	46		 inc	 esi
  000b5	84 c0		 test	 al, al
  000b7	75 ef		 jne	 SHORT $L537
$L538:

; 61   : 				}
; 62   : 				coffset+=0x00000004;

  000b9	83 c3 04	 add	 ebx, 4

; 63   : 				cnt+=2;

  000bc	83 c7 02	 add	 edi, 2
  000bf	83 c5 02	 add	 ebp, 2

; 64   : 			}
; 65   : 			else {

  000c2	eb ae		 jmp	 SHORT $L540
$L516:

; 66   : 				OutChar(arg[cnt]);
; 67   : 				cnt++;
; 68   : 			}
; 69   : 		}
; 70   : 		else {
; 71   : 			OutChar(arg[cnt]);

  000c4	33 c9		 xor	 ecx, ecx
  000c6	8a 4d 00	 mov	 cl, BYTE PTR [ebp]
$L532:
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ?OutChar@@YAXD@Z	; OutChar
  000cf	83 c4 04	 add	 esp, 4

; 72   : 			cnt++;

  000d2	47		 inc	 edi
  000d3	45		 inc	 ebp
  000d4	eb 9c		 jmp	 SHORT $L540
?printf@@YAXPBDZZ ENDP					; printf
_TEXT	ENDS
END
