; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	Process.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ?ProcessEntry@Process@@UAEXPAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Process@@QAE@PAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Process@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@Process@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dealloc@Process@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartProcess@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateProcess@@YAHPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Process@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?LastProcessID@@3IA				; LastProcessID
PUBLIC	?HeapHead@Process@@0PAVHeapAllocation@@A	; Process::HeapHead
_BSS	SEGMENT
?LastProcessID@@3IA DD 01H DUP (?)			; LastProcessID
?HeapHead@Process@@0PAVHeapAllocation@@A DD 01H DUP (?)	; Process::HeapHead
_BSS	ENDS
PUBLIC	??0ProcessNode@@QAE@XZ				; ProcessNode::ProcessNode
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.h
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT
??0ProcessNode@@QAE@XZ PROC NEAR			; ProcessNode::ProcessNode, COMDAT
; _this$ = ecx

; 103  : 	ProcessNode() {Next = NULL;};

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c3		 ret	 0
??0ProcessNode@@QAE@XZ ENDP				; ProcessNode::ProcessNode
_TEXT	ENDS
PUBLIC	?ProcessEntry@Process@@UAEXPAPAX@Z		; Process::ProcessEntry
PUBLIC	??0Process@@QAE@PAX0@Z				; Process::Process
PUBLIC	??_7Process@@6B@				; Process::`vftable'
;	COMDAT ??_7Process@@6B@
; File d:\my documents\projects\ooos\current\ooos\process.cpp
CONST	SEGMENT
??_7Process@@6B@ DD FLAT:?ProcessEntry@Process@@UAEXPAPAX@Z ; Process::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0Process@@QAE@PAX0@Z
_TEXT	SEGMENT
_Start$ = 8
_End$ = 12
??0Process@@QAE@PAX0@Z PROC NEAR			; Process::Process, COMDAT
; _this$ = ecx

; 11   : 	HeapStart = Start;
; 12   : 	HeapEnd = End;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _End$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _Start$[esp-4]
  0000a	89 90 7c 04 00
	00		 mov	 DWORD PTR [eax+1148], edx

; 13   : 	if (reinterpret_cast<unsigned long> (HeapEnd) - reinterpret_cast<unsigned long> (HeapStart) >= sizeof(HeapAllocation))

  00010	2b d1		 sub	 edx, ecx
  00012	83 fa 10	 cmp	 edx, 16			; 00000010H
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Process@@6B@
  0001b	89 88 78 04 00
	00		 mov	 DWORD PTR [eax+1144], ecx
  00021	72 3d		 jb	 SHORT $L532

; 14   : 	{
; 15   : 		HeapHead = reinterpret_cast<HeapAllocation *> (HeapStart);

  00023	89 0d 00 00 00
	00		 mov	 DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A, ecx ; Process::HeapHead

; 16   : 		HeapHead->AllocSize = 0;

  00029	33 d2		 xor	 edx, edx
  0002b	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 17   : 		HeapHead->Next = NULL;

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00034	89 11		 mov	 DWORD PTR [ecx], edx

; 18   : 		HeapHead->Prev = NULL;

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  0003c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 19   : 		HeapHead->SpaceSize = reinterpret_cast<unsigned long> (HeapEnd) - reinterpret_cast<unsigned long> (HeapStart) - sizeof(HeapAllocation);

  0003f	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00045	56		 push	 esi
  00046	2b 88 78 04 00
	00		 sub	 ecx, DWORD PTR [eax+1144]
  0004c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00052	83 e9 10	 sub	 ecx, 16			; 00000010H
  00055	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00058	5e		 pop	 esi

; 24   : 	}
; 25   : 	ControlBlock.ProcTSS.TaskLink = 0;

  00059	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 26   : }

  0005d	c2 08 00	 ret	 8
$L532:

; 20   : 	}
; 21   : 	else
; 22   : 	{
; 23   : 		HeapHead = NULL;

  00060	33 d2		 xor	 edx, edx
  00062	89 15 00 00 00
	00		 mov	 DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A, edx ; Process::HeapHead

; 24   : 	}
; 25   : 	ControlBlock.ProcTSS.TaskLink = 0;

  00068	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 26   : }

  0006c	c2 08 00	 ret	 8
??0Process@@QAE@PAX0@Z ENDP				; Process::Process
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.h
_TEXT	ENDS
;	COMDAT ?ProcessEntry@Process@@UAEXPAPAX@Z
_TEXT	SEGMENT
_args$ = 8
?ProcessEntry@Process@@UAEXPAPAX@Z PROC NEAR		; Process::ProcessEntry, COMDAT
; _this$ = ecx

; 79   : 	virtual void ProcessEntry(void** args) {};

  00000	c2 04 00	 ret	 4
?ProcessEntry@Process@@UAEXPAPAX@Z ENDP			; Process::ProcessEntry
_TEXT	ENDS
PUBLIC	??1Process@@QAE@XZ				; Process::~Process
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.cpp
;	COMDAT ??1Process@@QAE@XZ
_TEXT	SEGMENT
??1Process@@QAE@XZ PROC NEAR				; Process::~Process, COMDAT
; _this$ = ecx

; 29   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7Process@@6B@

; 30   : }

  00006	c3		 ret	 0
??1Process@@QAE@XZ ENDP					; Process::~Process
_TEXT	ENDS
PUBLIC	?Alloc@Process@@QAEPAXI@Z			; Process::Alloc
EXTRN	?Alloc@HeapAllocation@@QAEXIPAV1@@Z:NEAR	; HeapAllocation::Alloc
; Function compile flags: /Ogty
;	COMDAT ?Alloc@Process@@QAEPAXI@Z
_TEXT	SEGMENT
_Size$ = 8
?Alloc@Process@@QAEPAXI@Z PROC NEAR			; Process::Alloc, COMDAT
; _this$ = ecx

; 33   : {

  00000	56		 push	 esi

; 34   : 	if (HeapHead == NULL)

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00007	85 f6		 test	 esi, esi

; 35   : 	{
; 36   : 		return NULL;

  00009	74 12		 je	 SHORT $L550

; 37   : 	}
; 38   : 	// Find a spot that will fit the request
; 39   : 	for (HeapAllocation * cur = HeapHead; cur != NULL; cur = cur->Next)

  0000b	8b 4c 24 08	 mov	 ecx, DWORD PTR _Size$[esp]
  0000f	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
$L548:

; 40   : 	{
; 41   : 		// if we have found it then
; 42   : 		if (cur->SpaceSize >= sizeof(HeapAllocation) + Size)

  00012	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00015	73 0c		 jae	 SHORT $L647
  00017	8b 36		 mov	 esi, DWORD PTR [esi]
  00019	85 f6		 test	 esi, esi
  0001b	75 f5		 jne	 SHORT $L548
$L550:

; 48   : 		}
; 49   : 	}
; 50   : 	return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 51   : }

  00020	c2 04 00	 ret	 4
$L647:

; 43   : 		{
; 44   : 			// Create Allocation Object
; 45   : 			reinterpret_cast<HeapAllocation *> (reinterpret_cast<int> (cur) + sizeof(HeapAllocation) + cur->AllocSize)->Alloc(Size, cur);

  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	56		 push	 esi
  00027	51		 push	 ecx
  00028	8d 4c 30 10	 lea	 ecx, DWORD PTR [eax+esi+16]
  0002c	e8 00 00 00 00	 call	 ?Alloc@HeapAllocation@@QAEXIPAV1@@Z ; HeapAllocation::Alloc

; 46   : 			// Return Pointer
; 47   : 			return reinterpret_cast<void *> (reinterpret_cast<int> (cur) + sizeof(HeapAllocation) + cur->AllocSize + sizeof(HeapAllocation));

  00031	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00034	8d 44 31 20	 lea	 eax, DWORD PTR [ecx+esi+32]
  00038	5e		 pop	 esi

; 51   : }

  00039	c2 04 00	 ret	 4
?Alloc@Process@@QAEPAXI@Z ENDP				; Process::Alloc
_TEXT	ENDS
PUBLIC	?Dealloc@Process@@QAEXPAX@Z			; Process::Dealloc
EXTRN	?Dealloc@HeapAllocation@@QAEXXZ:NEAR		; HeapAllocation::Dealloc
; Function compile flags: /Ogty
;	COMDAT ?Dealloc@Process@@QAEXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
?Dealloc@Process@@QAEXPAX@Z PROC NEAR			; Process::Dealloc, COMDAT
; _this$ = ecx

; 55   : 	if (ptr != NULL)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L564

; 56   : 		reinterpret_cast<HeapAllocation *> (reinterpret_cast<unsigned long> (ptr) - sizeof(HeapAllocation))->Dealloc();

  00008	8d 48 f0	 lea	 ecx, DWORD PTR [eax-16]
  0000b	e8 00 00 00 00	 call	 ?Dealloc@HeapAllocation@@QAEXXZ ; HeapAllocation::Dealloc
$L564:

; 57   : }

  00010	c2 04 00	 ret	 4
?Dealloc@Process@@QAEXPAX@Z ENDP			; Process::Dealloc
_TEXT	ENDS
PUBLIC	?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z	; ProcessQueue::InsertEnd
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Ogty
;	COMDAT ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT
_NewProc$ = 8
?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z PROC NEAR	; ProcessQueue::InsertEnd, COMDAT
; _this$ = ecx

; 62   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 63   : 	//printf("insertend\n");
; 64   : 	ProcessNode * cur;
; 65   : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $L575

; 71   : }

  00009	8d a4 24 00 00
	00 00		 npad	 7
$L573:

; 63   : 	//printf("insertend\n");
; 64   : 	ProcessNode * cur;
; 65   : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00010	8b f0		 mov	 esi, eax
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	85 c0		 test	 eax, eax
  00016	75 f8		 jne	 SHORT $L573
$L575:

; 66   : 	/*{
; 67   : 		printf("cur: %d next: %d\n", cur, cur->Next);
; 68   : 	}*/
; 69   : 	cur->Next = new ProcessNode();

  00018	6a 08		 push	 8
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	74 13		 je	 SHORT $L658

; 70   : 	cur->Next->Proc = NewProc;

  00026	8b 4c 24 08	 mov	 ecx, DWORD PTR _NewProc$[esp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00030	89 06		 mov	 DWORD PTR [esi], eax
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00035	5e		 pop	 esi

; 71   : }

  00036	c2 04 00	 ret	 4
$L658:

; 70   : 	cur->Next->Proc = NewProc;

  00039	8b 54 24 08	 mov	 edx, DWORD PTR _NewProc$[esp]
  0003d	33 c0		 xor	 eax, eax
  0003f	89 06		 mov	 DWORD PTR [esi], eax
  00041	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00044	5e		 pop	 esi

; 71   : }

  00045	c2 04 00	 ret	 4
?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ENDP	; ProcessQueue::InsertEnd
_TEXT	ENDS
PUBLIC	?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ	; ProcessQueue::RemoveStart
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ
_TEXT	SEGMENT
?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ PROC NEAR	; ProcessQueue::RemoveStart, COMDAT
; _this$ = ecx

; 75   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 76   : 	ProcessNode * Temp = Head.Next;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 77   : 	Head.Proc = Head.Next->Proc;

  00005	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00008	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 78   : 	Head.Next = Head.Next->Next;

  0000b	8b 10		 mov	 edx, DWORD PTR [eax]

; 79   : 	delete Temp;

  0000d	50		 push	 eax
  0000e	89 16		 mov	 DWORD PTR [esi], edx
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 80   : 	return Head.Proc;

  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	83 c4 04	 add	 esp, 4
  0001b	5e		 pop	 esi

; 81   : }

  0001c	c3		 ret	 0
?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ ENDP	; ProcessQueue::RemoveStart
_TEXT	ENDS
PUBLIC	?Remove@ProcessQueue@@QAEXPAVProcess@@@Z	; ProcessQueue::Remove
; Function compile flags: /Ogty
;	COMDAT ?Remove@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT
_Proc$ = 8
?Remove@ProcessQueue@@QAEXPAVProcess@@@Z PROC NEAR	; ProcessQueue::Remove, COMDAT
; _this$ = ecx

; 85   : 	ProcessNode * prev = &Head;
; 86   : 	for(ProcessNode * cur = (&Head)->Next; cur != NULL; cur = cur->Next)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 27		 je	 SHORT $L591
  00006	8b 54 24 04	 mov	 edx, DWORD PTR _Proc$[esp-4]

; 95   : 	}
; 96   : }

  0000a	8d 9b 00 00 00
	00		 npad	 6

; 85   : 	ProcessNode * prev = &Head;
; 86   : 	for(ProcessNode * cur = (&Head)->Next; cur != NULL; cur = cur->Next)

$L589:

; 87   : 	{
; 88   : 		if (cur->Proc == Proc)

  00010	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00013	74 0b		 je	 SHORT $L674

; 92   : 			break;
; 93   : 		}
; 94   : 		prev = cur;

  00015	8b c8		 mov	 ecx, eax
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	85 c0		 test	 eax, eax
  0001b	75 f3		 jne	 SHORT $L589

; 95   : 	}
; 96   : }

  0001d	c2 04 00	 ret	 4
$L674:

; 89   : 		{
; 90   : 			prev->Next = cur->Next;

  00020	8b 10		 mov	 edx, DWORD PTR [eax]

; 91   : 			delete cur;

  00022	50		 push	 eax
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002a	83 c4 04	 add	 esp, 4
$L591:

; 95   : 	}
; 96   : }

  0002d	c2 04 00	 ret	 4
?Remove@ProcessQueue@@QAEXPAVProcess@@@Z ENDP		; ProcessQueue::Remove
_TEXT	ENDS
PUBLIC	?StartProcess@@YAXXZ				; StartProcess
; Function compile flags: /Ogty
;	COMDAT ?StartProcess@@YAXXZ
_TEXT	SEGMENT
_Proc$ = -4
?StartProcess@@YAXXZ PROC NEAR				; StartProcess, COMDAT

; 99   : {

  00000	51		 push	 ecx

; 100  : 	Process * Proc;
; 101  : 	__asm
; 102  : 	{
; 103  : 		MOV Proc, EAX

  00001	89 44 24 00	 mov	 DWORD PTR _Proc$[esp+4], eax

; 104  : 	}
; 105  : 	Proc->ProcessEntry(NULL);

  00005	8b 4c 24 00	 mov	 ecx, DWORD PTR _Proc$[esp+4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	6a 00		 push	 0
  0000d	ff 10		 call	 DWORD PTR [eax]

; 108  : }

  0000f	90		 npad	 1

; 104  : 	}
; 105  : 	Proc->ProcessEntry(NULL);

$L598:

; 106  : 	//__asm IRET
; 107  : 	while(1);

  00010	eb fe		 jmp	 SHORT $L598
?StartProcess@@YAXXZ ENDP				; StartProcess
_TEXT	ENDS
PUBLIC	?CreateProcess@@YAHPAVProcess@@@Z		; CreateProcess
EXTRN	?ActiveProcesses@@3PAVProcessQueue@@A:DWORD	; ActiveProcesses
EXTRN	?ReadyProcesses@@3PAVProcessQueue@@A:DWORD	; ReadyProcesses
EXTRN	?GDTAddress@@3PAKA:DWORD			; GDTAddress
; Function compile flags: /Ogty
;	COMDAT ?CreateProcess@@YAHPAVProcess@@@Z
_TEXT	SEGMENT
_Flags$ = -4
_NewProc$ = 8
?CreateProcess@@YAHPAVProcess@@@Z PROC NEAR		; CreateProcess, COMDAT

; 111  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 112  : 	//printf("Creating Process");
; 113  : 	DWORD Flags;
; 114  : 	__asm
; 115  : 	{
; 116  : 		PUSH EAX

  00003	50		 push	 eax

; 117  : 		PUSHFD

  00004	9c		 pushfd

; 118  : 		POP EAX

  00005	58		 pop	 eax

; 119  : 		MOV Flags, EAX

  00006	89 44 24 0c	 mov	 DWORD PTR _Flags$[esp+16], eax

; 120  : 		POP EAX

  0000a	58		 pop	 eax

; 121  : 		CLI

  0000b	fa		 cli

; 122  : 	};
; 123  : 	ActiveProcesses->InsertEnd(NewProc);

  0000c	8b 74 24 10	 mov	 esi, DWORD PTR _NewProc$[esp+8]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ActiveProcesses@@3PAVProcessQueue@@A ; ActiveProcesses
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ; ProcessQueue::InsertEnd

; 124  : 	ReadyProcesses->InsertEnd(NewProc);

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ReadyProcesses@@3PAVProcessQueue@@A ; ReadyProcesses
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ; ProcessQueue::InsertEnd

; 125  : 
; 126  : 	//printf("FindSlot");
; 127  : 	// Find a spare process slot
; 128  : 	int i;
; 129  : 	for (i = 0; GDTAddress[i * 2 + ProcessGDTOffset] != 0; ++i);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress
  0002d	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00030	83 c0 50	 add	 eax, 80			; 00000050H
  00033	33 c9		 xor	 ecx, ecx
  00035	85 d2		 test	 edx, edx
  00037	74 12		 je	 SHORT $L607

; 166  : 	}
; 167  : }

  00039	8d a4 24 00 00
	00 00		 npad	 7
$L605:

; 125  : 
; 126  : 	//printf("FindSlot");
; 127  : 	// Find a spare process slot
; 128  : 	int i;
; 129  : 	for (i = 0; GDTAddress[i * 2 + ProcessGDTOffset] != 0; ++i);

  00040	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00043	83 c0 08	 add	 eax, 8
  00046	41		 inc	 ecx
  00047	85 d2		 test	 edx, edx
  00049	75 f5		 jne	 SHORT $L605
$L607:

; 130  : 	//printf("FFound%d", i);
; 131  : 	//printf("pnum: %d\n", i);
; 132  : 	// Fill in the basic process details
; 133  : 	NewProc->ControlBlock.pid = ++LastProcessID;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?LastProcessID@@3IA ; LastProcessID
  00050	40		 inc	 eax
  00051	a3 00 00 00 00	 mov	 DWORD PTR ?LastProcessID@@3IA, eax ; LastProcessID
  00056	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 134  : 	//printf("pid:%d", NewProc->ControlBlock.pid);
; 135  : 	NewProc->ControlBlock.pnum = i;
; 136  : 	
; 137  : 	//printf("Set in GDT");
; 138  : 
; 139  : 	// create the TSS Descriptor in the GDT for the process
; 140  : 	GDTAddress[i*2+ ProcessGDTOffset] = ((reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFFFF) << 16 | 0x68);

  00059	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0005c	8b d0		 mov	 edx, eax
  0005e	c1 e2 10	 shl	 edx, 16			; 00000010H
  00061	81 e2 68 00 ff
	ff		 and	 edx, -65432		; ffff0068H
  00067	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0006a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress
  00070	83 ca 68	 or	 edx, 104		; 00000068H
  00073	89 54 cf 50	 mov	 DWORD PTR [edi+ecx*8+80], edx

; 141  : 	GDTAddress[i*2+1+ ProcessGDTOffset] = ((reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFF000000) | (reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFF0000) >> 16 | 0x008B00);

  00077	8b d0		 mov	 edx, eax
  00079	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  0007f	81 ca ff ff 00
	8b		 or	 edx, -1962868737	; 8b00ffffH
  00085	25 00 8b 00 ff	 and	 eax, -16741632		; ff008b00H
  0008a	c1 ea 10	 shr	 edx, 16			; 00000010H
  0008d	0b d0		 or	 edx, eax
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress
  00094	89 54 c8 54	 mov	 DWORD PTR [eax+ecx*8+84], edx

; 142  : 
; 143  : 	// set the values of the important bits of the TSS
; 144  : 	NewProc->ControlBlock.ProcTSS.SS = 0x10;

  00098	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 145  : 	NewProc->ControlBlock.ProcTSS.CS = 0x8;
; 146  : 	NewProc->ControlBlock.ProcTSS.DS = 0x10;
; 147  : 	NewProc->ControlBlock.ProcTSS.ES = 0x10;
; 148  : 	NewProc->ControlBlock.ProcTSS.FS = 0x10;
; 149  : 	NewProc->ControlBlock.ProcTSS.GS = 0x10;
; 150  : 
; 151  : 	NewProc->ControlBlock.ProcTSS.ESP = reinterpret_cast<unsigned long> (NewProc->Stack) + 1023;

  0009d	8d 8e 77 04 00
	00		 lea	 ecx, DWORD PTR [esi+1143]
  000a3	66 89 46 5c	 mov	 WORD PTR [esi+92], ax
  000a7	66 c7 46 58 08
	00		 mov	 WORD PTR [esi+88], 8
  000ad	66 89 46 60	 mov	 WORD PTR [esi+96], ax
  000b1	66 89 46 54	 mov	 WORD PTR [esi+84], ax
  000b5	66 89 46 64	 mov	 WORD PTR [esi+100], ax
  000b9	66 89 46 68	 mov	 WORD PTR [esi+104], ax
  000bd	89 4e 44	 mov	 DWORD PTR [esi+68], ecx

; 152  : 	NewProc->ControlBlock.ProcTSS.EAX = reinterpret_cast<unsigned long> (NewProc);

  000c0	89 76 34	 mov	 DWORD PTR [esi+52], esi

; 153  : 	NewProc->ControlBlock.ProcTSS.EIP = reinterpret_cast<unsigned long> (StartProcess);

  000c3	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], OFFSET FLAT:?StartProcess@@YAXXZ ; StartProcess

; 154  : 
; 155  : 	NewProc->ControlBlock.ProcTSS.EFLAGS = 0x202;

  000ca	c7 46 30 02 02
	00 00		 mov	 DWORD PTR [esi+48], 514	; 00000202H

; 156  : 
; 157  : 	//printf("Rest Flags");
; 158  : 
; 159  : 	__asm
; 160  : 	{
; 161  : 		PUSH EAX

  000d1	50		 push	 eax

; 162  : 		MOV EAX, Flags

  000d2	8b 44 24 0c	 mov	 eax, DWORD PTR _Flags$[esp+16]

; 163  : 		PUSH EAX

  000d6	50		 push	 eax

; 164  : 		POPFD

  000d7	9d		 popfd

; 165  : 		POP EAX

  000d8	58		 pop	 eax

; 166  : 	}
; 167  : }

  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	59		 pop	 ecx
  000dc	c3		 ret	 0
?CreateProcess@@YAHPAVProcess@@@Z ENDP			; CreateProcess
_TEXT	ENDS
END
