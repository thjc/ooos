; Listing generated by Microsoft (R) Optimizing Compiler Version 13.00.9466 

	TITLE	Process.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CG@NOPKNBNA@Error?0?5Could?5Not?5Allocate?5New?5Pr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06GNDDENNI@pid?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@JFMKFLKB@Address?5of?5new?5Proc?5TSS?3?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessEntry@Process@@UAEXPAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Process@@QAE@PAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Process@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Alloc@Process@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dealloc@Process@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pop_Front@ProcessQueue@@QAEPAVProcessNode@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Push_Back@ProcessQueue@@QAEXPAVProcessNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartProcess@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateProcess@@YAHPAVProcess@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Process@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?LastProcessID@@3IA				; LastProcessID
PUBLIC	?HeapHead@Process@@0PAVHeapAllocation@@A	; Process::HeapHead
_BSS	SEGMENT
?LastProcessID@@3IA DD 01H DUP (?)			; LastProcessID
?HeapHead@Process@@0PAVHeapAllocation@@A DD 01H DUP (?)	; Process::HeapHead
_BSS	ENDS
PUBLIC	??0ProcessNode@@QAE@XZ				; ProcessNode::ProcessNode
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.h
;	COMDAT ??0ProcessNode@@QAE@XZ
_TEXT	SEGMENT
??0ProcessNode@@QAE@XZ PROC NEAR			; ProcessNode::ProcessNode, COMDAT
; _this$ = ecx

; 103  : 	ProcessNode() {Next = NULL;};

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c3		 ret	 0
??0ProcessNode@@QAE@XZ ENDP				; ProcessNode::ProcessNode
_TEXT	ENDS
PUBLIC	?ProcessEntry@Process@@UAEXPAPAX@Z		; Process::ProcessEntry
PUBLIC	??0Process@@QAE@PAX0@Z				; Process::Process
PUBLIC	??_7Process@@6B@				; Process::`vftable'
;	COMDAT ??_7Process@@6B@
; File d:\my documents\projects\ooos\current\ooos\process.cpp
CONST	SEGMENT
??_7Process@@6B@ DD FLAT:?ProcessEntry@Process@@UAEXPAPAX@Z ; Process::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0Process@@QAE@PAX0@Z
_TEXT	SEGMENT
_Start$ = 8
_End$ = 12
??0Process@@QAE@PAX0@Z PROC NEAR			; Process::Process, COMDAT
; _this$ = ecx

; 11   : 	HeapStart = Start;
; 12   : 	HeapEnd = End;

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _End$[esp-4]
  00004	8b c1		 mov	 eax, ecx
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _Start$[esp-4]
  0000a	89 90 7c 04 00
	00		 mov	 DWORD PTR [eax+1148], edx

; 13   : 	if (reinterpret_cast<unsigned long> (HeapEnd) - reinterpret_cast<unsigned long> (HeapStart) >= sizeof(HeapAllocation))

  00010	2b d1		 sub	 edx, ecx
  00012	83 fa 10	 cmp	 edx, 16			; 00000010H
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7Process@@6B@
  0001b	89 88 78 04 00
	00		 mov	 DWORD PTR [eax+1144], ecx
  00021	72 3d		 jb	 SHORT $L535

; 14   : 	{
; 15   : 		HeapHead = reinterpret_cast<HeapAllocation *> (HeapStart);

  00023	89 0d 00 00 00
	00		 mov	 DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A, ecx ; Process::HeapHead

; 16   : 		HeapHead->AllocSize = 0;

  00029	33 d2		 xor	 edx, edx
  0002b	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 17   : 		HeapHead->Next = NULL;

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00034	89 11		 mov	 DWORD PTR [ecx], edx

; 18   : 		HeapHead->Prev = NULL;

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  0003c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 19   : 		HeapHead->SpaceSize = reinterpret_cast<unsigned long> (HeapEnd) - reinterpret_cast<unsigned long> (HeapStart) - sizeof(HeapAllocation);

  0003f	8b 88 7c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1148]
  00045	56		 push	 esi
  00046	2b 88 78 04 00
	00		 sub	 ecx, DWORD PTR [eax+1144]
  0004c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00052	83 e9 10	 sub	 ecx, 16			; 00000010H
  00055	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00058	5e		 pop	 esi

; 24   : 	}
; 25   : 	ControlBlock.ProcTSS.TaskLink = 0;

  00059	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 26   : }

  0005d	c2 08 00	 ret	 8
$L535:

; 20   : 	}
; 21   : 	else
; 22   : 	{
; 23   : 		HeapHead = NULL;

  00060	33 d2		 xor	 edx, edx
  00062	89 15 00 00 00
	00		 mov	 DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A, edx ; Process::HeapHead

; 24   : 	}
; 25   : 	ControlBlock.ProcTSS.TaskLink = 0;

  00068	66 89 50 0c	 mov	 WORD PTR [eax+12], dx

; 26   : }

  0006c	c2 08 00	 ret	 8
??0Process@@QAE@PAX0@Z ENDP				; Process::Process
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.h
_TEXT	ENDS
;	COMDAT ?ProcessEntry@Process@@UAEXPAPAX@Z
_TEXT	SEGMENT
_args$ = 8
?ProcessEntry@Process@@UAEXPAPAX@Z PROC NEAR		; Process::ProcessEntry, COMDAT
; _this$ = ecx

; 79   : 	virtual void ProcessEntry(void** args) {};

  00000	c2 04 00	 ret	 4
?ProcessEntry@Process@@UAEXPAPAX@Z ENDP			; Process::ProcessEntry
_TEXT	ENDS
PUBLIC	??1Process@@QAE@XZ				; Process::~Process
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.cpp
;	COMDAT ??1Process@@QAE@XZ
_TEXT	SEGMENT
??1Process@@QAE@XZ PROC NEAR				; Process::~Process, COMDAT
; _this$ = ecx

; 29   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7Process@@6B@

; 30   : }

  00006	c3		 ret	 0
??1Process@@QAE@XZ ENDP					; Process::~Process
_TEXT	ENDS
PUBLIC	?Alloc@Process@@QAEPAXI@Z			; Process::Alloc
EXTRN	?Alloc@HeapAllocation@@QAEXIPAV1@@Z:NEAR	; HeapAllocation::Alloc
; Function compile flags: /Ogty
;	COMDAT ?Alloc@Process@@QAEPAXI@Z
_TEXT	SEGMENT
_Size$ = 8
?Alloc@Process@@QAEPAXI@Z PROC NEAR			; Process::Alloc, COMDAT
; _this$ = ecx

; 33   : {

  00000	56		 push	 esi

; 34   : 	if (HeapHead == NULL)

  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?HeapHead@Process@@0PAVHeapAllocation@@A ; Process::HeapHead
  00007	85 f6		 test	 esi, esi

; 35   : 	{
; 36   : 		return NULL;

  00009	74 12		 je	 SHORT $L553

; 37   : 	}
; 38   : 	// Find a spot that will fit the request
; 39   : 	for (HeapAllocation * cur = HeapHead; cur != NULL; cur = cur->Next)

  0000b	8b 4c 24 08	 mov	 ecx, DWORD PTR _Size$[esp]
  0000f	8d 41 10	 lea	 eax, DWORD PTR [ecx+16]
$L551:

; 40   : 	{
; 41   : 		// if we have found it then
; 42   : 		if (cur->SpaceSize >= sizeof(HeapAllocation) + Size)

  00012	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00015	73 0c		 jae	 SHORT $L676
  00017	8b 36		 mov	 esi, DWORD PTR [esi]
  00019	85 f6		 test	 esi, esi
  0001b	75 f5		 jne	 SHORT $L551
$L553:

; 48   : 		}
; 49   : 	}
; 50   : 	return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 51   : }

  00020	c2 04 00	 ret	 4
$L676:

; 43   : 		{
; 44   : 			// Create Allocation Object
; 45   : 			reinterpret_cast<HeapAllocation *> (reinterpret_cast<int> (cur) + sizeof(HeapAllocation) + cur->AllocSize)->Alloc(Size, cur);

  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	56		 push	 esi
  00027	51		 push	 ecx
  00028	8d 4c 30 10	 lea	 ecx, DWORD PTR [eax+esi+16]
  0002c	e8 00 00 00 00	 call	 ?Alloc@HeapAllocation@@QAEXIPAV1@@Z ; HeapAllocation::Alloc

; 46   : 			// Return Pointer
; 47   : 			return reinterpret_cast<void *> (reinterpret_cast<int> (cur) + sizeof(HeapAllocation) + cur->AllocSize + sizeof(HeapAllocation));

  00031	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00034	8d 44 31 20	 lea	 eax, DWORD PTR [ecx+esi+32]
  00038	5e		 pop	 esi

; 51   : }

  00039	c2 04 00	 ret	 4
?Alloc@Process@@QAEPAXI@Z ENDP				; Process::Alloc
_TEXT	ENDS
PUBLIC	?Dealloc@Process@@QAEXPAX@Z			; Process::Dealloc
EXTRN	?Dealloc@HeapAllocation@@QAEXXZ:NEAR		; HeapAllocation::Dealloc
; Function compile flags: /Ogty
;	COMDAT ?Dealloc@Process@@QAEXPAX@Z
_TEXT	SEGMENT
_ptr$ = 8
?Dealloc@Process@@QAEXPAX@Z PROC NEAR			; Process::Dealloc, COMDAT
; _this$ = ecx

; 55   : 	if (ptr != NULL)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00004	85 c0		 test	 eax, eax
  00006	74 08		 je	 SHORT $L567

; 56   : 		reinterpret_cast<HeapAllocation *> (reinterpret_cast<unsigned long> (ptr) - sizeof(HeapAllocation))->Dealloc();

  00008	8d 48 f0	 lea	 ecx, DWORD PTR [eax-16]
  0000b	e8 00 00 00 00	 call	 ?Dealloc@HeapAllocation@@QAEXXZ ; HeapAllocation::Dealloc
$L567:

; 57   : }

  00010	c2 04 00	 ret	 4
?Dealloc@Process@@QAEXPAX@Z ENDP			; Process::Dealloc
_TEXT	ENDS
PUBLIC	?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z	; ProcessQueue::InsertEnd
PUBLIC	??_C@_0CG@NOPKNBNA@Error?0?5Could?5Not?5Allocate?5New?5Pr@ ; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	?printf@@YAXPBDZZ:NEAR				; printf
;	COMDAT ??_C@_0CG@NOPKNBNA@Error?0?5Could?5Not?5Allocate?5New?5Pr@
; File d:\my documents\projects\ooos\current\ooos\process.h
CONST	SEGMENT
??_C@_0CG@NOPKNBNA@Error?0?5Could?5Not?5Allocate?5New?5Pr@ DB 'Error, Cou'
	DB	'ld Not Allocate New Process', 00H		; `string'
; Function compile flags: /Ogty
; File d:\my documents\projects\ooos\current\ooos\process.cpp
CONST	ENDS
;	COMDAT ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT
_NewProc$ = 8
?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z PROC NEAR	; ProcessQueue::InsertEnd, COMDAT
; _this$ = ecx

; 62   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 63   : 	//printf("insertend\n");
; 64   : 	ProcessNode * cur;
; 65   : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 0f		 je	 SHORT $L578

; 76   : }

  00009	8d a4 24 00 00
	00 00		 npad	 7
$L576:

; 63   : 	//printf("insertend\n");
; 64   : 	ProcessNode * cur;
; 65   : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00010	8b f0		 mov	 esi, eax
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	85 c0		 test	 eax, eax
  00016	75 f8		 jne	 SHORT $L576
$L578:

; 66   : 	/*{
; 67   : 		printf("cur: %d next: %d\n", cur, cur->Next);
; 68   : 	}*/
; 69   : 	cur->Next = new ProcessNode();

  00018	6a 08		 push	 8
  0001a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	74 08		 je	 SHORT $L687
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	eb 02		 jmp	 SHORT $L688
$L687:
  0002e	33 c0		 xor	 eax, eax
$L688:

; 70   : 	if (cur->Next == NULL)

  00030	85 c0		 test	 eax, eax
  00032	89 06		 mov	 DWORD PTR [esi], eax
  00034	5e		 pop	 esi
  00035	75 0f		 jne	 SHORT $L695

; 71   : 	{
; 72   : 		printf("Error, Could Not Allocate New Process");

  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CG@NOPKNBNA@Error?0?5Could?5Not?5Allocate?5New?5Pr@
  0003c	e8 00 00 00 00	 call	 ?printf@@YAXPBDZZ	; printf
  00041	83 c4 04	 add	 esp, 4
$L584:

; 73   : 		while (1);

  00044	eb fe		 jmp	 SHORT $L584
$L695:

; 74   : 	}
; 75   : 	cur->Next->Proc = NewProc;

  00046	8b 4c 24 04	 mov	 ecx, DWORD PTR _NewProc$[esp-4]
  0004a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 76   : }

  0004d	c2 04 00	 ret	 4
?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ENDP	; ProcessQueue::InsertEnd
_TEXT	ENDS
PUBLIC	?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ	; ProcessQueue::RemoveStart
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ
_TEXT	SEGMENT
?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ PROC NEAR	; ProcessQueue::RemoveStart, COMDAT
; _this$ = ecx

; 80   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 81   : 	ProcessNode * Temp = Head.Next;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]

; 82   : 	Head.Proc = Head.Next->Proc;
; 83   : 	Head.Next = Head.Next->Next;
; 84   : 	if (Temp != NULL)

  00005	85 c0		 test	 eax, eax
  00007	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 16		 mov	 DWORD PTR [esi], edx
  00011	74 0e		 je	 SHORT $L590

; 85   : 	{
; 86   : 		delete Temp;

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 87   : 		return Head.Proc;

  00019	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001c	83 c4 04	 add	 esp, 4
  0001f	5e		 pop	 esi

; 90   : }

  00020	c3		 ret	 0
$L590:

; 88   : 	}
; 89   : 	return NULL;

  00021	33 c0		 xor	 eax, eax
  00023	5e		 pop	 esi

; 90   : }

  00024	c3		 ret	 0
?RemoveStart@ProcessQueue@@QAEPAVProcess@@XZ ENDP	; ProcessQueue::RemoveStart
_TEXT	ENDS
PUBLIC	?Remove@ProcessQueue@@QAEXPAVProcess@@@Z	; ProcessQueue::Remove
; Function compile flags: /Ogty
;	COMDAT ?Remove@ProcessQueue@@QAEXPAVProcess@@@Z
_TEXT	SEGMENT
_Proc$ = 8
?Remove@ProcessQueue@@QAEXPAVProcess@@@Z PROC NEAR	; ProcessQueue::Remove, COMDAT
; _this$ = ecx

; 94   : 	ProcessNode * prev = &Head;
; 95   : 	for(ProcessNode * cur = (&Head)->Next; cur != NULL; cur = cur->Next)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	74 27		 je	 SHORT $L600
  00006	8b 54 24 04	 mov	 edx, DWORD PTR _Proc$[esp-4]

; 104  : 	}
; 105  : }

  0000a	8d 9b 00 00 00
	00		 npad	 6

; 94   : 	ProcessNode * prev = &Head;
; 95   : 	for(ProcessNode * cur = (&Head)->Next; cur != NULL; cur = cur->Next)

$L598:

; 96   : 	{
; 97   : 		if (cur->Proc == Proc)

  00010	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  00013	74 0b		 je	 SHORT $L705

; 101  : 			break;
; 102  : 		}
; 103  : 		prev = cur;

  00015	8b c8		 mov	 ecx, eax
  00017	8b 00		 mov	 eax, DWORD PTR [eax]
  00019	85 c0		 test	 eax, eax
  0001b	75 f3		 jne	 SHORT $L598

; 104  : 	}
; 105  : }

  0001d	c2 04 00	 ret	 4
$L705:

; 98   : 		{
; 99   : 			prev->Next = cur->Next;

  00020	8b 10		 mov	 edx, DWORD PTR [eax]

; 100  : 			delete cur;

  00022	50		 push	 eax
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002a	83 c4 04	 add	 esp, 4
$L600:

; 104  : 	}
; 105  : }

  0002d	c2 04 00	 ret	 4
?Remove@ProcessQueue@@QAEXPAVProcess@@@Z ENDP		; ProcessQueue::Remove
_TEXT	ENDS
PUBLIC	?Pop_Front@ProcessQueue@@QAEPAVProcessNode@@XZ	; ProcessQueue::Pop_Front
; Function compile flags: /Ogty
;	COMDAT ?Pop_Front@ProcessQueue@@QAEPAVProcessNode@@XZ
_TEXT	SEGMENT
?Pop_Front@ProcessQueue@@QAEPAVProcessNode@@XZ PROC NEAR ; ProcessQueue::Pop_Front, COMDAT
; _this$ = ecx

; 109  : 	ProcessNode * Temp = Head.Next;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 110  : 	Head.Proc = Head.Next->Proc;

  00002	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00005	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 111  : 	Head.Next = Head.Next->Next;

  00008	8b 10		 mov	 edx, DWORD PTR [eax]
  0000a	89 11		 mov	 DWORD PTR [ecx], edx

; 112  : 	//delete Temp;
; 113  : 	return Temp;
; 114  : }

  0000c	c3		 ret	 0
?Pop_Front@ProcessQueue@@QAEPAVProcessNode@@XZ ENDP	; ProcessQueue::Pop_Front
_TEXT	ENDS
PUBLIC	?Push_Back@ProcessQueue@@QAEXPAVProcessNode@@@Z	; ProcessQueue::Push_Back
; Function compile flags: /Ogty
;	COMDAT ?Push_Back@ProcessQueue@@QAEXPAVProcessNode@@@Z
_TEXT	SEGMENT
_NewProc$ = 8
?Push_Back@ProcessQueue@@QAEXPAVProcessNode@@@Z PROC NEAR ; ProcessQueue::Push_Back, COMDAT
; _this$ = ecx

; 118  : 	if (NewProc == NULL)

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _NewProc$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	74 18		 je	 SHORT $L610

; 119  : 		return;
; 120  : 	//printf("insertend\n");
; 121  : 	ProcessNode * cur;
; 122  : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00008	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0a		 je	 SHORT $L615

; 128  : 	//cur->Next->Proc = NewProc;
; 129  : }

  0000e	8b ff		 npad	 2
$L613:

; 119  : 		return;
; 120  : 	//printf("insertend\n");
; 121  : 	ProcessNode * cur;
; 122  : 	for(cur = &Head; cur->Next != NULL; cur = cur->Next);

  00010	8b c8		 mov	 ecx, eax
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	85 c0		 test	 eax, eax
  00016	75 f8		 jne	 SHORT $L613
$L615:

; 123  : 	/*{
; 124  : 		printf("cur: %d next: %d\n", cur, cur->Next);
; 125  : 	}*/
; 126  : 	cur->Next = NewProc;

  00018	89 11		 mov	 DWORD PTR [ecx], edx

; 127  : 	NewProc->Next = NULL;

  0001a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$L610:

; 128  : 	//cur->Next->Proc = NewProc;
; 129  : }

  00020	c2 04 00	 ret	 4
?Push_Back@ProcessQueue@@QAEXPAVProcessNode@@@Z ENDP	; ProcessQueue::Push_Back
_TEXT	ENDS
PUBLIC	?StartProcess@@YAXXZ				; StartProcess
; Function compile flags: /Ogty
;	COMDAT ?StartProcess@@YAXXZ
_TEXT	SEGMENT
_Proc$ = -4
?StartProcess@@YAXXZ PROC NEAR				; StartProcess, COMDAT

; 136  : {

  00000	51		 push	 ecx

; 137  : 	Process * Proc;
; 138  : 	__asm
; 139  : 	{
; 140  : 		MOV Proc, EAX

  00001	89 44 24 00	 mov	 DWORD PTR _Proc$[esp+4], eax

; 141  : 	}
; 142  : 	Proc->ProcessEntry(NULL);

  00005	8b 4c 24 00	 mov	 ecx, DWORD PTR _Proc$[esp+4]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	6a 00		 push	 0
  0000d	ff 10		 call	 DWORD PTR [eax]

; 145  : }

  0000f	90		 npad	 1

; 141  : 	}
; 142  : 	Proc->ProcessEntry(NULL);

$L620:

; 143  : 	//__asm IRET
; 144  : 	while(1);

  00010	eb fe		 jmp	 SHORT $L620
?StartProcess@@YAXXZ ENDP				; StartProcess
_TEXT	ENDS
PUBLIC	?CreateProcess@@YAHPAVProcess@@@Z		; CreateProcess
PUBLIC	??_C@_06GNDDENNI@pid?3?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BN@JFMKFLKB@Address?5of?5new?5Proc?5TSS?3?5?$CFd?6?$AA@ ; `string'
EXTRN	?ActiveProcesses@@3PAVProcessQueue@@A:DWORD	; ActiveProcesses
EXTRN	?ReadyProcesses@@3PAVProcessQueue@@A:DWORD	; ReadyProcesses
EXTRN	?GDTAddress@@3PAKA:DWORD			; GDTAddress
;	COMDAT ??_C@_06GNDDENNI@pid?3?$CFd?$AA@
CONST	SEGMENT
??_C@_06GNDDENNI@pid?3?$CFd?$AA@ DB 'pid:%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JFMKFLKB@Address?5of?5new?5Proc?5TSS?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@JFMKFLKB@Address?5of?5new?5Proc?5TSS?3?5?$CFd?6?$AA@ DB 'Addres'
	DB	's of new Proc TSS: %d', 0aH, 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?CreateProcess@@YAHPAVProcess@@@Z
_TEXT	SEGMENT
_Flags$ = -4
_NewProc$ = 8
?CreateProcess@@YAHPAVProcess@@@Z PROC NEAR		; CreateProcess, COMDAT

; 149  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 150  : 	//printf("Creating Process");
; 151  : 	DWORD Flags;
; 152  : 	__asm
; 153  : 	{
; 154  : 		PUSH EAX

  00003	50		 push	 eax

; 155  : 		PUSHFD

  00004	9c		 pushfd

; 156  : 		POP EAX

  00005	58		 pop	 eax

; 157  : 		MOV Flags, EAX

  00006	89 44 24 0c	 mov	 DWORD PTR _Flags$[esp+16], eax

; 158  : 		POP EAX

  0000a	58		 pop	 eax

; 159  : 		CLI

  0000b	fa		 cli

; 160  : 	};
; 161  : 	ActiveProcesses->InsertEnd(NewProc);

  0000c	8b 74 24 10	 mov	 esi, DWORD PTR _NewProc$[esp+8]
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ActiveProcesses@@3PAVProcessQueue@@A ; ActiveProcesses
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ; ProcessQueue::InsertEnd

; 162  : 	ReadyProcesses->InsertEnd(NewProc);

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ReadyProcesses@@3PAVProcessQueue@@A ; ReadyProcesses
  00022	56		 push	 esi
  00023	e8 00 00 00 00	 call	 ?InsertEnd@ProcessQueue@@QAEXPAVProcess@@@Z ; ProcessQueue::InsertEnd

; 163  : 
; 164  : 	//printf("FindSlot");
; 165  : 	// Find a spare process slot
; 166  : 	int i;
; 167  : 	for (i = 0; GDTAddress[i * 2 + ProcessGDTOffset] != 0; ++i);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress
  0002d	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00030	83 c0 50	 add	 eax, 80			; 00000050H
  00033	33 ff		 xor	 edi, edi
  00035	85 c9		 test	 ecx, ecx
  00037	74 12		 je	 SHORT $L629

; 209  : 		// dont need STI because flags are returned to initial state
; 210  : 		//STI
; 211  : 	}
; 212  : }

  00039	8d a4 24 00 00
	00 00		 npad	 7
$L627:

; 163  : 
; 164  : 	//printf("FindSlot");
; 165  : 	// Find a spare process slot
; 166  : 	int i;
; 167  : 	for (i = 0; GDTAddress[i * 2 + ProcessGDTOffset] != 0; ++i);

  00040	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00043	83 c0 08	 add	 eax, 8
  00046	47		 inc	 edi
  00047	85 c9		 test	 ecx, ecx
  00049	75 f5		 jne	 SHORT $L627
$L629:

; 168  : 	//printf("FFound%d", i);
; 169  : 	//printf("pnum: %d\n", i);
; 170  : 	// Fill in the basic process details
; 171  : 	NewProc->ControlBlock.pid = ++LastProcessID;

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?LastProcessID@@3IA ; LastProcessID
  00050	40		 inc	 eax

; 172  : 	printf("pid:%d", NewProc->ControlBlock.pid);

  00051	50		 push	 eax
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?LastProcessID@@3IA, eax ; LastProcessID
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06GNDDENNI@pid?3?$CFd?$AA@
  0005c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005f	e8 00 00 00 00	 call	 ?printf@@YAXPBDZZ	; printf

; 173  : 	NewProc->ControlBlock.pnum = i;
; 174  : 	
; 175  : 	//printf("Set in GDT");
; 176  : 
; 177  : 	// create the TSS Descriptor in the GDT for the process
; 178  : 	GDTAddress[i*2+ ProcessGDTOffset] = ((reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFFFF) << 16 | 0x68);

  00064	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00067	8b c8		 mov	 ecx, eax
  00069	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0006c	81 e1 68 00 ff
	ff		 and	 ecx, -65432		; ffff0068H
  00072	83 c9 68	 or	 ecx, 104		; 00000068H
  00075	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00078	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress
  0007e	89 4c fa 50	 mov	 DWORD PTR [edx+edi*8+80], ecx

; 179  : 	GDTAddress[i*2+1+ ProcessGDTOffset] = ((reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFF000000) | (reinterpret_cast<const unsigned long> (&NewProc->ControlBlock.ProcTSS) & 0xFF0000) >> 16 | 0x008B00);

  00082	8b c8		 mov	 ecx, eax
  00084	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0008a	81 c9 ff ff 00
	8b		 or	 ecx, -1962868737	; 8b00ffffH
  00090	8b d0		 mov	 edx, eax
  00092	81 e2 00 8b 00
	ff		 and	 edx, -16741632		; ff008b00H
  00098	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0009b	0b ca		 or	 ecx, edx
  0009d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GDTAddress@@3PAKA ; GDTAddress

; 180  : 
; 181  : 	printf("Address of new Proc TSS: %d\n", &NewProc->ControlBlock.ProcTSS);

  000a3	50		 push	 eax
  000a4	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BN@JFMKFLKB@Address?5of?5new?5Proc?5TSS?3?5?$CFd?6?$AA@
  000a9	89 4c fa 54	 mov	 DWORD PTR [edx+edi*8+84], ecx
  000ad	e8 00 00 00 00	 call	 ?printf@@YAXPBDZZ	; printf

; 182  : 
; 183  : 	// set the values of the important bits of the TSS
; 184  : 	NewProc->ControlBlock.ProcTSS.SS = 0x10;

  000b2	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  000b7	66 89 46 5c	 mov	 WORD PTR [esi+92], ax

; 185  : 	NewProc->ControlBlock.ProcTSS.CS = 0x8;
; 186  : 	NewProc->ControlBlock.ProcTSS.DS = 0x10;

  000bb	66 89 46 60	 mov	 WORD PTR [esi+96], ax

; 187  : 	NewProc->ControlBlock.ProcTSS.ES = 0x10;

  000bf	66 89 46 54	 mov	 WORD PTR [esi+84], ax

; 188  : 	NewProc->ControlBlock.ProcTSS.FS = 0x10;

  000c3	66 89 46 64	 mov	 WORD PTR [esi+100], ax

; 189  : 	NewProc->ControlBlock.ProcTSS.GS = 0x10;

  000c7	66 89 46 68	 mov	 WORD PTR [esi+104], ax

; 190  : 
; 191  : 	NewProc->ControlBlock.ProcTSS.ESP = reinterpret_cast<unsigned long> (NewProc->Stack) + 1023;

  000cb	8d 86 77 04 00
	00		 lea	 eax, DWORD PTR [esi+1143]
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
  000d4	66 c7 46 58 08
	00		 mov	 WORD PTR [esi+88], 8
  000da	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 192  : 	NewProc->ControlBlock.ProcTSS.EAX = reinterpret_cast<unsigned long> (NewProc);

  000dd	89 76 34	 mov	 DWORD PTR [esi+52], esi

; 193  : 	NewProc->ControlBlock.ProcTSS.EIP = reinterpret_cast<unsigned long> (StartProcess);

  000e0	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], OFFSET FLAT:?StartProcess@@YAXXZ ; StartProcess

; 194  : 
; 195  : 	// all flags cleared excep interrupt enable and the reserved bit
; 196  : 	NewProc->ControlBlock.ProcTSS.EFLAGS = 0x202;

  000e7	c7 46 30 02 02
	00 00		 mov	 DWORD PTR [esi+48], 514	; 00000202H

; 197  : 
; 198  : 
; 199  : 
; 200  : 	//printf("Rest Flags");
; 201  : 	
; 202  : 	__asm
; 203  : 	{
; 204  : 		PUSH EAX

  000ee	50		 push	 eax

; 205  : 		MOV EAX, Flags

  000ef	8b 44 24 0c	 mov	 eax, DWORD PTR _Flags$[esp+16]

; 206  : 		PUSH EAX

  000f3	50		 push	 eax

; 207  : 		POPFD

  000f4	9d		 popfd

; 208  : 		POP EAX

  000f5	58		 pop	 eax

; 209  : 		// dont need STI because flags are returned to initial state
; 210  : 		//STI
; 211  : 	}
; 212  : }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	59		 pop	 ecx
  000f9	c3		 ret	 0
?CreateProcess@@YAHPAVProcess@@@Z ENDP			; CreateProcess
_TEXT	ENDS
END
